import{b as T}from"./react-CwtnApNd.js";const w=r=>{let i;const t=new Set,o=(l,s)=>{const h=typeof l=="function"?l(i):l;if(!Object.is(h,i)){const y=i;i=s??(typeof h!="object"||h===null)?h:Object.assign({},i,h),t.forEach(f=>f(i,y))}},n=()=>i,c={setState:o,getState:n,getInitialState:()=>m,subscribe:l=>(t.add(l),()=>t.delete(l))},m=i=r(o,n,c);return c},C=r=>w(r),D=r=>r;function N(r,i=D){const t=T.useSyncExternalStore(r.subscribe,()=>i(r.getState()),()=>i(r.getInitialState()));return T.useDebugValue(t),t}const j=r=>{const i=C(r),t=o=>N(i,o);return Object.assign(t,i),t},H=r=>j(r),J={BASE_URL:"/mumin/",DEV:!1,MODE:"production",PROD:!0,SSR:!1},O=new Map,_=r=>{const i=O.get(r);return i?Object.fromEntries(Object.entries(i.stores).map(([t,o])=>[t,o.getState()])):{}},k=(r,i,t)=>{if(r===void 0)return{type:"untracked",connection:i.connect(t)};const o=O.get(t.name);if(o)return{type:"tracked",store:r,...o};const n={connection:i.connect(t),stores:{}};return O.set(t.name,n),{type:"tracked",store:r,...n}},P=(r,i={})=>(t,o,n)=>{const{enabled:u,anonymousActionType:g,store:c,...m}=i;let l;try{l=(u??(J?"production":void 0)!=="production")&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!l)return r(t,o,n);const{connection:s,...h}=k(c,l,m);let y=!0;n.setState=(e,S,d)=>{const a=t(e,S);if(!y)return a;const p=d===void 0?{type:g||"anonymous"}:typeof d=="string"?{type:d}:d;return c===void 0?(s==null||s.send(p,o()),a):(s==null||s.send({...p,type:`${c}/${p.type}`},{..._(m.name),[c]:n.getState()}),a)};const f=(...e)=>{const S=y;y=!1,t(...e),y=S},v=r(n.setState,o,n);if(h.type==="untracked"?s==null||s.init(v):(h.stores[h.store]=n,s==null||s.init(Object.fromEntries(Object.entries(h.stores).map(([e,S])=>[e,e===h.store?v:S.getState()])))),n.dispatchFromDevtools&&typeof n.dispatch=="function"){const e=n.dispatch;n.dispatch=(...S)=>{e(...S)}}return s.subscribe(e=>{var S;switch(e.type){case"ACTION":if(typeof e.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return I(e.payload,d=>{if(d.type==="__setState"){if(c===void 0){f(d.state);return}Object.keys(d.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format.
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const a=d.state[c];if(a==null)return;JSON.stringify(n.getState())!==JSON.stringify(a)&&f(a);return}n.dispatchFromDevtools&&typeof n.dispatch=="function"&&n.dispatch(d)});case"DISPATCH":switch(e.payload.type){case"RESET":return f(v),c===void 0?s==null?void 0:s.init(n.getState()):s==null?void 0:s.init(_(m.name));case"COMMIT":if(c===void 0){s==null||s.init(n.getState());return}return s==null?void 0:s.init(_(m.name));case"ROLLBACK":return I(e.state,d=>{if(c===void 0){f(d),s==null||s.init(n.getState());return}f(d[c]),s==null||s.init(_(m.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return I(e.state,d=>{if(c===void 0){f(d);return}JSON.stringify(n.getState())!==JSON.stringify(d[c])&&f(d[c])});case"IMPORT_STATE":{const{nextLiftedState:d}=e.payload,a=(S=d.computedStates.slice(-1)[0])==null?void 0:S.state;if(!a)return;f(c===void 0?a:a[c]),s==null||s.send(null,d);return}case"PAUSE_RECORDING":return y=!y}return}}),v},L=P,I=(r,i)=>{let t;try{t=JSON.parse(r)}catch(o){console.error("[zustand devtools middleware] Could not parse the received json",o)}t!==void 0&&i(t)};function U(r,i){let t;try{t=r()}catch{return}return{getItem:n=>{var u;const g=m=>m===null?null:JSON.parse(m,void 0),c=(u=t.getItem(n))!=null?u:null;return c instanceof Promise?c.then(g):g(c)},setItem:(n,u)=>t.setItem(n,JSON.stringify(u,void 0)),removeItem:n=>t.removeItem(n)}}const E=r=>i=>{try{const t=r(i);return t instanceof Promise?t:{then(o){return E(o)(t)},catch(o){return this}}}catch(t){return{then(o){return this},catch(o){return E(o)(t)}}}},x=(r,i)=>(t,o,n)=>{let u={storage:U(()=>localStorage),partialize:e=>e,version:0,merge:(e,S)=>({...S,...e}),...i},g=!1;const c=new Set,m=new Set;let l=u.storage;if(!l)return r((...e)=>{console.warn(`[zustand persist middleware] Unable to update item '${u.name}', the given storage is currently unavailable.`),t(...e)},o,n);const s=()=>{const e=u.partialize({...o()});return l.setItem(u.name,{state:e,version:u.version})},h=n.setState;n.setState=(e,S)=>{h(e,S),s()};const y=r((...e)=>{t(...e),s()},o,n);n.getInitialState=()=>y;let f;const v=()=>{var e,S;if(!l)return;g=!1,c.forEach(a=>{var p;return a((p=o())!=null?p:y)});const d=((S=u.onRehydrateStorage)==null?void 0:S.call(u,(e=o())!=null?e:y))||void 0;return E(l.getItem.bind(l))(u.name).then(a=>{if(a)if(typeof a.version=="number"&&a.version!==u.version){if(u.migrate){const p=u.migrate(a.state,a.version);return p instanceof Promise?p.then(b=>[!0,b]):[!0,p]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,a.state];return[!1,void 0]}).then(a=>{var p;const[b,R]=a;if(f=u.merge(R,(p=o())!=null?p:y),t(f,!0),b)return s()}).then(()=>{d==null||d(f,void 0),f=o(),g=!0,m.forEach(a=>a(f))}).catch(a=>{d==null||d(void 0,a)})};return n.persist={setOptions:e=>{u={...u,...e},e.storage&&(l=e.storage)},clearStorage:()=>{l==null||l.removeItem(u.name)},getOptions:()=>u,rehydrate:()=>v(),hasHydrated:()=>g,onHydrate:e=>(c.add(e),()=>{c.delete(e)}),onFinishHydration:e=>(m.add(e),()=>{m.delete(e)})},u.skipHydration||v(),f||y},M=x;export{H as c,L as d,M as p};
